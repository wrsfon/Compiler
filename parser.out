Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> stmt
Rule 1     stmt -> stmt stmt
Rule 2     stmt -> assignExp .
Rule 3     stmt -> arrayExp .
Rule 4     stmt -> showExp .
Rule 5     stmt -> cmpExp .
Rule 6     stmt -> loopExp .
Rule 7     assignExp -> IDENTIFIER ASSIGN exp
Rule 8     assignExp -> t_CONSTANT IDENTIFIER ASSIGN exp
Rule 9     arrayExp -> ARRAY IDENTIFIER ASSIGN [ member ]
Rule 10    member -> CONSTANT member2
Rule 11    member2 -> , CONSTANT member2
Rule 12    member2 -> empty empty empty
Rule 13    loopExp -> LOOP assignL stmt FINISH
Rule 14    assignL -> IDENTIFIER ASSIGN expL
Rule 15    expL -> ( CONSTANT , CONSTANT , CONSTANT )
Rule 16    cmpExp -> CMP cond { stmt }
Rule 17    val -> IDENTIFIER
Rule 18    val -> CONSTANT
Rule 19    val -> array_val
Rule 20    array_val -> IDENTIFIER [ CONSTANT ]
Rule 21    array_val -> IDENTIFIER [ IDENTIFIER ]
Rule 22    exp -> val
Rule 23    showExp -> SHOW CONSTANT
Rule 24    showExp -> SHOW IDENTIFIER
Rule 25    showExp -> SHOW STRING
Rule 26    cond -> exp < exp
Rule 27    cond -> exp > exp
Rule 28    cond -> exp = exp
Rule 29    cond -> exp NOTEQ exp
Rule 30    exp -> exp + exp
Rule 31    exp -> exp - exp
Rule 32    exp -> exp / exp
Rule 33    exp -> exp * exp
Rule 34    exp -> exp % exp
Rule 35    exp -> val + val
Rule 36    exp -> val - val
Rule 37    exp -> val / val
Rule 38    exp -> val * val
Rule 39    exp -> val % val
Rule 40    exp -> - exp
Rule 41    exp -> ( exp )
Rule 42    empty -> <empty>

Terminals, with rules where they appear

%                    : 34 39
(                    : 15 41
)                    : 15 41
*                    : 33 38
+                    : 30 35
,                    : 11 15 15
-                    : 31 36 40
.                    : 2 3 4 5 6
/                    : 32 37
<                    : 26
=                    : 28
>                    : 27
ARRAY                : 9
ASSIGN               : 7 8 9 14
CMP                  : 16
CONSTANT             : 10 11 15 15 15 18 20 23
FINISH               : 13
IDENTIFIER           : 7 8 9 14 17 20 21 21 24
LOOP                 : 13
NOTEQ                : 29
SHOW                 : 23 24 25
STRING               : 25
[                    : 9 20 21
]                    : 9 20 21
error                : 
t_CONSTANT           : 8
{                    : 16
}                    : 16

Nonterminals, with rules where they appear

arrayExp             : 3
array_val            : 19
assignExp            : 2
assignL              : 13
cmpExp               : 5
cond                 : 16
empty                : 12 12 12
exp                  : 7 8 26 26 27 27 28 28 29 29 30 30 31 31 32 32 33 33 34 34 40 41
expL                 : 14
loopExp              : 6
member               : 9
member2              : 10 11
showExp              : 4
stmt                 : 1 1 13 16 0
val                  : 22 35 35 36 36 37 37 38 38 39 39

Parsing method: LALR

state 0

    (0) S' -> . stmt
    (1) stmt -> . stmt stmt
    (2) stmt -> . assignExp .
    (3) stmt -> . arrayExp .
    (4) stmt -> . showExp .
    (5) stmt -> . cmpExp .
    (6) stmt -> . loopExp .
    (7) assignExp -> . IDENTIFIER ASSIGN exp
    (8) assignExp -> . t_CONSTANT IDENTIFIER ASSIGN exp
    (9) arrayExp -> . ARRAY IDENTIFIER ASSIGN [ member ]
    (23) showExp -> . SHOW CONSTANT
    (24) showExp -> . SHOW IDENTIFIER
    (25) showExp -> . SHOW STRING
    (16) cmpExp -> . CMP cond { stmt }
    (13) loopExp -> . LOOP assignL stmt FINISH

    IDENTIFIER      shift and go to state 7
    t_CONSTANT      shift and go to state 8
    ARRAY           shift and go to state 9
    SHOW            shift and go to state 10
    CMP             shift and go to state 11
    LOOP            shift and go to state 12

    stmt                           shift and go to state 1
    assignExp                      shift and go to state 2
    arrayExp                       shift and go to state 3
    showExp                        shift and go to state 4
    cmpExp                         shift and go to state 5
    loopExp                        shift and go to state 6

state 1

    (0) S' -> stmt .
    (1) stmt -> stmt . stmt
    (1) stmt -> . stmt stmt
    (2) stmt -> . assignExp .
    (3) stmt -> . arrayExp .
    (4) stmt -> . showExp .
    (5) stmt -> . cmpExp .
    (6) stmt -> . loopExp .
    (7) assignExp -> . IDENTIFIER ASSIGN exp
    (8) assignExp -> . t_CONSTANT IDENTIFIER ASSIGN exp
    (9) arrayExp -> . ARRAY IDENTIFIER ASSIGN [ member ]
    (23) showExp -> . SHOW CONSTANT
    (24) showExp -> . SHOW IDENTIFIER
    (25) showExp -> . SHOW STRING
    (16) cmpExp -> . CMP cond { stmt }
    (13) loopExp -> . LOOP assignL stmt FINISH

    IDENTIFIER      shift and go to state 7
    t_CONSTANT      shift and go to state 8
    ARRAY           shift and go to state 9
    SHOW            shift and go to state 10
    CMP             shift and go to state 11
    LOOP            shift and go to state 12

    stmt                           shift and go to state 13
    assignExp                      shift and go to state 2
    arrayExp                       shift and go to state 3
    showExp                        shift and go to state 4
    cmpExp                         shift and go to state 5
    loopExp                        shift and go to state 6

state 2

    (2) stmt -> assignExp . .

    .               shift and go to state 14


state 3

    (3) stmt -> arrayExp . .

    .               shift and go to state 15


state 4

    (4) stmt -> showExp . .

    .               shift and go to state 16


state 5

    (5) stmt -> cmpExp . .

    .               shift and go to state 17


state 6

    (6) stmt -> loopExp . .

    .               shift and go to state 18


state 7

    (7) assignExp -> IDENTIFIER . ASSIGN exp

    ASSIGN          shift and go to state 19


state 8

    (8) assignExp -> t_CONSTANT . IDENTIFIER ASSIGN exp

    IDENTIFIER      shift and go to state 20


state 9

    (9) arrayExp -> ARRAY . IDENTIFIER ASSIGN [ member ]

    IDENTIFIER      shift and go to state 21


state 10

    (23) showExp -> SHOW . CONSTANT
    (24) showExp -> SHOW . IDENTIFIER
    (25) showExp -> SHOW . STRING

    CONSTANT        shift and go to state 22
    IDENTIFIER      shift and go to state 23
    STRING          shift and go to state 24


state 11

    (16) cmpExp -> CMP . cond { stmt }
    (26) cond -> . exp < exp
    (27) cond -> . exp > exp
    (28) cond -> . exp = exp
    (29) cond -> . exp NOTEQ exp
    (22) exp -> . val
    (30) exp -> . exp + exp
    (31) exp -> . exp - exp
    (32) exp -> . exp / exp
    (33) exp -> . exp * exp
    (34) exp -> . exp % exp
    (35) exp -> . val + val
    (36) exp -> . val - val
    (37) exp -> . val / val
    (38) exp -> . val * val
    (39) exp -> . val % val
    (40) exp -> . - exp
    (41) exp -> . ( exp )
    (17) val -> . IDENTIFIER
    (18) val -> . CONSTANT
    (19) val -> . array_val
    (20) array_val -> . IDENTIFIER [ CONSTANT ]
    (21) array_val -> . IDENTIFIER [ IDENTIFIER ]

    -               shift and go to state 28
    (               shift and go to state 29
    IDENTIFIER      shift and go to state 30
    CONSTANT        shift and go to state 31

    cond                           shift and go to state 25
    exp                            shift and go to state 26
    val                            shift and go to state 27
    array_val                      shift and go to state 32

state 12

    (13) loopExp -> LOOP . assignL stmt FINISH
    (14) assignL -> . IDENTIFIER ASSIGN expL

    IDENTIFIER      shift and go to state 34

    assignL                        shift and go to state 33

state 13

    (1) stmt -> stmt stmt .
    (1) stmt -> stmt . stmt
    (1) stmt -> . stmt stmt
    (2) stmt -> . assignExp .
    (3) stmt -> . arrayExp .
    (4) stmt -> . showExp .
    (5) stmt -> . cmpExp .
    (6) stmt -> . loopExp .
    (7) assignExp -> . IDENTIFIER ASSIGN exp
    (8) assignExp -> . t_CONSTANT IDENTIFIER ASSIGN exp
    (9) arrayExp -> . ARRAY IDENTIFIER ASSIGN [ member ]
    (23) showExp -> . SHOW CONSTANT
    (24) showExp -> . SHOW IDENTIFIER
    (25) showExp -> . SHOW STRING
    (16) cmpExp -> . CMP cond { stmt }
    (13) loopExp -> . LOOP assignL stmt FINISH

  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for t_CONSTANT resolved as shift
  ! shift/reduce conflict for ARRAY resolved as shift
  ! shift/reduce conflict for SHOW resolved as shift
  ! shift/reduce conflict for CMP resolved as shift
  ! shift/reduce conflict for LOOP resolved as shift
    $end            reduce using rule 1 (stmt -> stmt stmt .)
    FINISH          reduce using rule 1 (stmt -> stmt stmt .)
    }               reduce using rule 1 (stmt -> stmt stmt .)
    IDENTIFIER      shift and go to state 7
    t_CONSTANT      shift and go to state 8
    ARRAY           shift and go to state 9
    SHOW            shift and go to state 10
    CMP             shift and go to state 11
    LOOP            shift and go to state 12

  ! IDENTIFIER      [ reduce using rule 1 (stmt -> stmt stmt .) ]
  ! t_CONSTANT      [ reduce using rule 1 (stmt -> stmt stmt .) ]
  ! ARRAY           [ reduce using rule 1 (stmt -> stmt stmt .) ]
  ! SHOW            [ reduce using rule 1 (stmt -> stmt stmt .) ]
  ! CMP             [ reduce using rule 1 (stmt -> stmt stmt .) ]
  ! LOOP            [ reduce using rule 1 (stmt -> stmt stmt .) ]

    stmt                           shift and go to state 13
    assignExp                      shift and go to state 2
    arrayExp                       shift and go to state 3
    showExp                        shift and go to state 4
    cmpExp                         shift and go to state 5
    loopExp                        shift and go to state 6

state 14

    (2) stmt -> assignExp . .

    IDENTIFIER      reduce using rule 2 (stmt -> assignExp . .)
    t_CONSTANT      reduce using rule 2 (stmt -> assignExp . .)
    ARRAY           reduce using rule 2 (stmt -> assignExp . .)
    SHOW            reduce using rule 2 (stmt -> assignExp . .)
    CMP             reduce using rule 2 (stmt -> assignExp . .)
    LOOP            reduce using rule 2 (stmt -> assignExp . .)
    $end            reduce using rule 2 (stmt -> assignExp . .)
    FINISH          reduce using rule 2 (stmt -> assignExp . .)
    }               reduce using rule 2 (stmt -> assignExp . .)


state 15

    (3) stmt -> arrayExp . .

    IDENTIFIER      reduce using rule 3 (stmt -> arrayExp . .)
    t_CONSTANT      reduce using rule 3 (stmt -> arrayExp . .)
    ARRAY           reduce using rule 3 (stmt -> arrayExp . .)
    SHOW            reduce using rule 3 (stmt -> arrayExp . .)
    CMP             reduce using rule 3 (stmt -> arrayExp . .)
    LOOP            reduce using rule 3 (stmt -> arrayExp . .)
    $end            reduce using rule 3 (stmt -> arrayExp . .)
    FINISH          reduce using rule 3 (stmt -> arrayExp . .)
    }               reduce using rule 3 (stmt -> arrayExp . .)


state 16

    (4) stmt -> showExp . .

    IDENTIFIER      reduce using rule 4 (stmt -> showExp . .)
    t_CONSTANT      reduce using rule 4 (stmt -> showExp . .)
    ARRAY           reduce using rule 4 (stmt -> showExp . .)
    SHOW            reduce using rule 4 (stmt -> showExp . .)
    CMP             reduce using rule 4 (stmt -> showExp . .)
    LOOP            reduce using rule 4 (stmt -> showExp . .)
    $end            reduce using rule 4 (stmt -> showExp . .)
    FINISH          reduce using rule 4 (stmt -> showExp . .)
    }               reduce using rule 4 (stmt -> showExp . .)


state 17

    (5) stmt -> cmpExp . .

    IDENTIFIER      reduce using rule 5 (stmt -> cmpExp . .)
    t_CONSTANT      reduce using rule 5 (stmt -> cmpExp . .)
    ARRAY           reduce using rule 5 (stmt -> cmpExp . .)
    SHOW            reduce using rule 5 (stmt -> cmpExp . .)
    CMP             reduce using rule 5 (stmt -> cmpExp . .)
    LOOP            reduce using rule 5 (stmt -> cmpExp . .)
    $end            reduce using rule 5 (stmt -> cmpExp . .)
    FINISH          reduce using rule 5 (stmt -> cmpExp . .)
    }               reduce using rule 5 (stmt -> cmpExp . .)


state 18

    (6) stmt -> loopExp . .

    IDENTIFIER      reduce using rule 6 (stmt -> loopExp . .)
    t_CONSTANT      reduce using rule 6 (stmt -> loopExp . .)
    ARRAY           reduce using rule 6 (stmt -> loopExp . .)
    SHOW            reduce using rule 6 (stmt -> loopExp . .)
    CMP             reduce using rule 6 (stmt -> loopExp . .)
    LOOP            reduce using rule 6 (stmt -> loopExp . .)
    $end            reduce using rule 6 (stmt -> loopExp . .)
    FINISH          reduce using rule 6 (stmt -> loopExp . .)
    }               reduce using rule 6 (stmt -> loopExp . .)


state 19

    (7) assignExp -> IDENTIFIER ASSIGN . exp
    (22) exp -> . val
    (30) exp -> . exp + exp
    (31) exp -> . exp - exp
    (32) exp -> . exp / exp
    (33) exp -> . exp * exp
    (34) exp -> . exp % exp
    (35) exp -> . val + val
    (36) exp -> . val - val
    (37) exp -> . val / val
    (38) exp -> . val * val
    (39) exp -> . val % val
    (40) exp -> . - exp
    (41) exp -> . ( exp )
    (17) val -> . IDENTIFIER
    (18) val -> . CONSTANT
    (19) val -> . array_val
    (20) array_val -> . IDENTIFIER [ CONSTANT ]
    (21) array_val -> . IDENTIFIER [ IDENTIFIER ]

    -               shift and go to state 28
    (               shift and go to state 29
    IDENTIFIER      shift and go to state 30
    CONSTANT        shift and go to state 31

    exp                            shift and go to state 35
    val                            shift and go to state 27
    array_val                      shift and go to state 32

state 20

    (8) assignExp -> t_CONSTANT IDENTIFIER . ASSIGN exp

    ASSIGN          shift and go to state 36


state 21

    (9) arrayExp -> ARRAY IDENTIFIER . ASSIGN [ member ]

    ASSIGN          shift and go to state 37


state 22

    (23) showExp -> SHOW CONSTANT .

    .               reduce using rule 23 (showExp -> SHOW CONSTANT .)


state 23

    (24) showExp -> SHOW IDENTIFIER .

    .               reduce using rule 24 (showExp -> SHOW IDENTIFIER .)


state 24

    (25) showExp -> SHOW STRING .

    .               reduce using rule 25 (showExp -> SHOW STRING .)


state 25

    (16) cmpExp -> CMP cond . { stmt }

    {               shift and go to state 38


state 26

    (26) cond -> exp . < exp
    (27) cond -> exp . > exp
    (28) cond -> exp . = exp
    (29) cond -> exp . NOTEQ exp
    (30) exp -> exp . + exp
    (31) exp -> exp . - exp
    (32) exp -> exp . / exp
    (33) exp -> exp . * exp
    (34) exp -> exp . % exp

    <               shift and go to state 39
    >               shift and go to state 40
    =               shift and go to state 41
    NOTEQ           shift and go to state 42
    +               shift and go to state 43
    -               shift and go to state 44
    /               shift and go to state 45
    *               shift and go to state 46
    %               shift and go to state 47


state 27

    (22) exp -> val .
    (35) exp -> val . + val
    (36) exp -> val . - val
    (37) exp -> val . / val
    (38) exp -> val . * val
    (39) exp -> val . % val

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for % resolved as shift
    <               reduce using rule 22 (exp -> val .)
    >               reduce using rule 22 (exp -> val .)
    =               reduce using rule 22 (exp -> val .)
    NOTEQ           reduce using rule 22 (exp -> val .)
    .               reduce using rule 22 (exp -> val .)
    )               reduce using rule 22 (exp -> val .)
    {               reduce using rule 22 (exp -> val .)
    +               shift and go to state 48
    -               shift and go to state 49
    /               shift and go to state 50
    *               shift and go to state 51
    %               shift and go to state 52

  ! +               [ reduce using rule 22 (exp -> val .) ]
  ! -               [ reduce using rule 22 (exp -> val .) ]
  ! /               [ reduce using rule 22 (exp -> val .) ]
  ! *               [ reduce using rule 22 (exp -> val .) ]
  ! %               [ reduce using rule 22 (exp -> val .) ]


state 28

    (40) exp -> - . exp
    (22) exp -> . val
    (30) exp -> . exp + exp
    (31) exp -> . exp - exp
    (32) exp -> . exp / exp
    (33) exp -> . exp * exp
    (34) exp -> . exp % exp
    (35) exp -> . val + val
    (36) exp -> . val - val
    (37) exp -> . val / val
    (38) exp -> . val * val
    (39) exp -> . val % val
    (40) exp -> . - exp
    (41) exp -> . ( exp )
    (17) val -> . IDENTIFIER
    (18) val -> . CONSTANT
    (19) val -> . array_val
    (20) array_val -> . IDENTIFIER [ CONSTANT ]
    (21) array_val -> . IDENTIFIER [ IDENTIFIER ]

    -               shift and go to state 28
    (               shift and go to state 29
    IDENTIFIER      shift and go to state 30
    CONSTANT        shift and go to state 31

    exp                            shift and go to state 53
    val                            shift and go to state 27
    array_val                      shift and go to state 32

state 29

    (41) exp -> ( . exp )
    (22) exp -> . val
    (30) exp -> . exp + exp
    (31) exp -> . exp - exp
    (32) exp -> . exp / exp
    (33) exp -> . exp * exp
    (34) exp -> . exp % exp
    (35) exp -> . val + val
    (36) exp -> . val - val
    (37) exp -> . val / val
    (38) exp -> . val * val
    (39) exp -> . val % val
    (40) exp -> . - exp
    (41) exp -> . ( exp )
    (17) val -> . IDENTIFIER
    (18) val -> . CONSTANT
    (19) val -> . array_val
    (20) array_val -> . IDENTIFIER [ CONSTANT ]
    (21) array_val -> . IDENTIFIER [ IDENTIFIER ]

    -               shift and go to state 28
    (               shift and go to state 29
    IDENTIFIER      shift and go to state 30
    CONSTANT        shift and go to state 31

    exp                            shift and go to state 54
    val                            shift and go to state 27
    array_val                      shift and go to state 32

state 30

    (17) val -> IDENTIFIER .
    (20) array_val -> IDENTIFIER . [ CONSTANT ]
    (21) array_val -> IDENTIFIER . [ IDENTIFIER ]

    +               reduce using rule 17 (val -> IDENTIFIER .)
    -               reduce using rule 17 (val -> IDENTIFIER .)
    /               reduce using rule 17 (val -> IDENTIFIER .)
    *               reduce using rule 17 (val -> IDENTIFIER .)
    %               reduce using rule 17 (val -> IDENTIFIER .)
    <               reduce using rule 17 (val -> IDENTIFIER .)
    >               reduce using rule 17 (val -> IDENTIFIER .)
    =               reduce using rule 17 (val -> IDENTIFIER .)
    NOTEQ           reduce using rule 17 (val -> IDENTIFIER .)
    .               reduce using rule 17 (val -> IDENTIFIER .)
    )               reduce using rule 17 (val -> IDENTIFIER .)
    {               reduce using rule 17 (val -> IDENTIFIER .)
    [               shift and go to state 55


state 31

    (18) val -> CONSTANT .

    +               reduce using rule 18 (val -> CONSTANT .)
    -               reduce using rule 18 (val -> CONSTANT .)
    /               reduce using rule 18 (val -> CONSTANT .)
    *               reduce using rule 18 (val -> CONSTANT .)
    %               reduce using rule 18 (val -> CONSTANT .)
    <               reduce using rule 18 (val -> CONSTANT .)
    >               reduce using rule 18 (val -> CONSTANT .)
    =               reduce using rule 18 (val -> CONSTANT .)
    NOTEQ           reduce using rule 18 (val -> CONSTANT .)
    .               reduce using rule 18 (val -> CONSTANT .)
    )               reduce using rule 18 (val -> CONSTANT .)
    {               reduce using rule 18 (val -> CONSTANT .)


state 32

    (19) val -> array_val .

    +               reduce using rule 19 (val -> array_val .)
    -               reduce using rule 19 (val -> array_val .)
    /               reduce using rule 19 (val -> array_val .)
    *               reduce using rule 19 (val -> array_val .)
    %               reduce using rule 19 (val -> array_val .)
    <               reduce using rule 19 (val -> array_val .)
    >               reduce using rule 19 (val -> array_val .)
    =               reduce using rule 19 (val -> array_val .)
    NOTEQ           reduce using rule 19 (val -> array_val .)
    .               reduce using rule 19 (val -> array_val .)
    )               reduce using rule 19 (val -> array_val .)
    {               reduce using rule 19 (val -> array_val .)


state 33

    (13) loopExp -> LOOP assignL . stmt FINISH
    (1) stmt -> . stmt stmt
    (2) stmt -> . assignExp .
    (3) stmt -> . arrayExp .
    (4) stmt -> . showExp .
    (5) stmt -> . cmpExp .
    (6) stmt -> . loopExp .
    (7) assignExp -> . IDENTIFIER ASSIGN exp
    (8) assignExp -> . t_CONSTANT IDENTIFIER ASSIGN exp
    (9) arrayExp -> . ARRAY IDENTIFIER ASSIGN [ member ]
    (23) showExp -> . SHOW CONSTANT
    (24) showExp -> . SHOW IDENTIFIER
    (25) showExp -> . SHOW STRING
    (16) cmpExp -> . CMP cond { stmt }
    (13) loopExp -> . LOOP assignL stmt FINISH

    IDENTIFIER      shift and go to state 7
    t_CONSTANT      shift and go to state 8
    ARRAY           shift and go to state 9
    SHOW            shift and go to state 10
    CMP             shift and go to state 11
    LOOP            shift and go to state 12

    stmt                           shift and go to state 56
    assignExp                      shift and go to state 2
    arrayExp                       shift and go to state 3
    showExp                        shift and go to state 4
    cmpExp                         shift and go to state 5
    loopExp                        shift and go to state 6

state 34

    (14) assignL -> IDENTIFIER . ASSIGN expL

    ASSIGN          shift and go to state 57


state 35

    (7) assignExp -> IDENTIFIER ASSIGN exp .
    (30) exp -> exp . + exp
    (31) exp -> exp . - exp
    (32) exp -> exp . / exp
    (33) exp -> exp . * exp
    (34) exp -> exp . % exp

    .               reduce using rule 7 (assignExp -> IDENTIFIER ASSIGN exp .)
    +               shift and go to state 43
    -               shift and go to state 44
    /               shift and go to state 45
    *               shift and go to state 46
    %               shift and go to state 47


state 36

    (8) assignExp -> t_CONSTANT IDENTIFIER ASSIGN . exp
    (22) exp -> . val
    (30) exp -> . exp + exp
    (31) exp -> . exp - exp
    (32) exp -> . exp / exp
    (33) exp -> . exp * exp
    (34) exp -> . exp % exp
    (35) exp -> . val + val
    (36) exp -> . val - val
    (37) exp -> . val / val
    (38) exp -> . val * val
    (39) exp -> . val % val
    (40) exp -> . - exp
    (41) exp -> . ( exp )
    (17) val -> . IDENTIFIER
    (18) val -> . CONSTANT
    (19) val -> . array_val
    (20) array_val -> . IDENTIFIER [ CONSTANT ]
    (21) array_val -> . IDENTIFIER [ IDENTIFIER ]

    -               shift and go to state 28
    (               shift and go to state 29
    IDENTIFIER      shift and go to state 30
    CONSTANT        shift and go to state 31

    exp                            shift and go to state 58
    val                            shift and go to state 27
    array_val                      shift and go to state 32

state 37

    (9) arrayExp -> ARRAY IDENTIFIER ASSIGN . [ member ]

    [               shift and go to state 59


state 38

    (16) cmpExp -> CMP cond { . stmt }
    (1) stmt -> . stmt stmt
    (2) stmt -> . assignExp .
    (3) stmt -> . arrayExp .
    (4) stmt -> . showExp .
    (5) stmt -> . cmpExp .
    (6) stmt -> . loopExp .
    (7) assignExp -> . IDENTIFIER ASSIGN exp
    (8) assignExp -> . t_CONSTANT IDENTIFIER ASSIGN exp
    (9) arrayExp -> . ARRAY IDENTIFIER ASSIGN [ member ]
    (23) showExp -> . SHOW CONSTANT
    (24) showExp -> . SHOW IDENTIFIER
    (25) showExp -> . SHOW STRING
    (16) cmpExp -> . CMP cond { stmt }
    (13) loopExp -> . LOOP assignL stmt FINISH

    IDENTIFIER      shift and go to state 7
    t_CONSTANT      shift and go to state 8
    ARRAY           shift and go to state 9
    SHOW            shift and go to state 10
    CMP             shift and go to state 11
    LOOP            shift and go to state 12

    stmt                           shift and go to state 60
    assignExp                      shift and go to state 2
    arrayExp                       shift and go to state 3
    showExp                        shift and go to state 4
    cmpExp                         shift and go to state 5
    loopExp                        shift and go to state 6

state 39

    (26) cond -> exp < . exp
    (22) exp -> . val
    (30) exp -> . exp + exp
    (31) exp -> . exp - exp
    (32) exp -> . exp / exp
    (33) exp -> . exp * exp
    (34) exp -> . exp % exp
    (35) exp -> . val + val
    (36) exp -> . val - val
    (37) exp -> . val / val
    (38) exp -> . val * val
    (39) exp -> . val % val
    (40) exp -> . - exp
    (41) exp -> . ( exp )
    (17) val -> . IDENTIFIER
    (18) val -> . CONSTANT
    (19) val -> . array_val
    (20) array_val -> . IDENTIFIER [ CONSTANT ]
    (21) array_val -> . IDENTIFIER [ IDENTIFIER ]

    -               shift and go to state 28
    (               shift and go to state 29
    IDENTIFIER      shift and go to state 30
    CONSTANT        shift and go to state 31

    exp                            shift and go to state 61
    val                            shift and go to state 27
    array_val                      shift and go to state 32

state 40

    (27) cond -> exp > . exp
    (22) exp -> . val
    (30) exp -> . exp + exp
    (31) exp -> . exp - exp
    (32) exp -> . exp / exp
    (33) exp -> . exp * exp
    (34) exp -> . exp % exp
    (35) exp -> . val + val
    (36) exp -> . val - val
    (37) exp -> . val / val
    (38) exp -> . val * val
    (39) exp -> . val % val
    (40) exp -> . - exp
    (41) exp -> . ( exp )
    (17) val -> . IDENTIFIER
    (18) val -> . CONSTANT
    (19) val -> . array_val
    (20) array_val -> . IDENTIFIER [ CONSTANT ]
    (21) array_val -> . IDENTIFIER [ IDENTIFIER ]

    -               shift and go to state 28
    (               shift and go to state 29
    IDENTIFIER      shift and go to state 30
    CONSTANT        shift and go to state 31

    exp                            shift and go to state 62
    val                            shift and go to state 27
    array_val                      shift and go to state 32

state 41

    (28) cond -> exp = . exp
    (22) exp -> . val
    (30) exp -> . exp + exp
    (31) exp -> . exp - exp
    (32) exp -> . exp / exp
    (33) exp -> . exp * exp
    (34) exp -> . exp % exp
    (35) exp -> . val + val
    (36) exp -> . val - val
    (37) exp -> . val / val
    (38) exp -> . val * val
    (39) exp -> . val % val
    (40) exp -> . - exp
    (41) exp -> . ( exp )
    (17) val -> . IDENTIFIER
    (18) val -> . CONSTANT
    (19) val -> . array_val
    (20) array_val -> . IDENTIFIER [ CONSTANT ]
    (21) array_val -> . IDENTIFIER [ IDENTIFIER ]

    -               shift and go to state 28
    (               shift and go to state 29
    IDENTIFIER      shift and go to state 30
    CONSTANT        shift and go to state 31

    exp                            shift and go to state 63
    val                            shift and go to state 27
    array_val                      shift and go to state 32

state 42

    (29) cond -> exp NOTEQ . exp
    (22) exp -> . val
    (30) exp -> . exp + exp
    (31) exp -> . exp - exp
    (32) exp -> . exp / exp
    (33) exp -> . exp * exp
    (34) exp -> . exp % exp
    (35) exp -> . val + val
    (36) exp -> . val - val
    (37) exp -> . val / val
    (38) exp -> . val * val
    (39) exp -> . val % val
    (40) exp -> . - exp
    (41) exp -> . ( exp )
    (17) val -> . IDENTIFIER
    (18) val -> . CONSTANT
    (19) val -> . array_val
    (20) array_val -> . IDENTIFIER [ CONSTANT ]
    (21) array_val -> . IDENTIFIER [ IDENTIFIER ]

    -               shift and go to state 28
    (               shift and go to state 29
    IDENTIFIER      shift and go to state 30
    CONSTANT        shift and go to state 31

    exp                            shift and go to state 64
    val                            shift and go to state 27
    array_val                      shift and go to state 32

state 43

    (30) exp -> exp + . exp
    (22) exp -> . val
    (30) exp -> . exp + exp
    (31) exp -> . exp - exp
    (32) exp -> . exp / exp
    (33) exp -> . exp * exp
    (34) exp -> . exp % exp
    (35) exp -> . val + val
    (36) exp -> . val - val
    (37) exp -> . val / val
    (38) exp -> . val * val
    (39) exp -> . val % val
    (40) exp -> . - exp
    (41) exp -> . ( exp )
    (17) val -> . IDENTIFIER
    (18) val -> . CONSTANT
    (19) val -> . array_val
    (20) array_val -> . IDENTIFIER [ CONSTANT ]
    (21) array_val -> . IDENTIFIER [ IDENTIFIER ]

    -               shift and go to state 28
    (               shift and go to state 29
    IDENTIFIER      shift and go to state 30
    CONSTANT        shift and go to state 31

    exp                            shift and go to state 65
    val                            shift and go to state 27
    array_val                      shift and go to state 32

state 44

    (31) exp -> exp - . exp
    (22) exp -> . val
    (30) exp -> . exp + exp
    (31) exp -> . exp - exp
    (32) exp -> . exp / exp
    (33) exp -> . exp * exp
    (34) exp -> . exp % exp
    (35) exp -> . val + val
    (36) exp -> . val - val
    (37) exp -> . val / val
    (38) exp -> . val * val
    (39) exp -> . val % val
    (40) exp -> . - exp
    (41) exp -> . ( exp )
    (17) val -> . IDENTIFIER
    (18) val -> . CONSTANT
    (19) val -> . array_val
    (20) array_val -> . IDENTIFIER [ CONSTANT ]
    (21) array_val -> . IDENTIFIER [ IDENTIFIER ]

    -               shift and go to state 28
    (               shift and go to state 29
    IDENTIFIER      shift and go to state 30
    CONSTANT        shift and go to state 31

    exp                            shift and go to state 66
    val                            shift and go to state 27
    array_val                      shift and go to state 32

state 45

    (32) exp -> exp / . exp
    (22) exp -> . val
    (30) exp -> . exp + exp
    (31) exp -> . exp - exp
    (32) exp -> . exp / exp
    (33) exp -> . exp * exp
    (34) exp -> . exp % exp
    (35) exp -> . val + val
    (36) exp -> . val - val
    (37) exp -> . val / val
    (38) exp -> . val * val
    (39) exp -> . val % val
    (40) exp -> . - exp
    (41) exp -> . ( exp )
    (17) val -> . IDENTIFIER
    (18) val -> . CONSTANT
    (19) val -> . array_val
    (20) array_val -> . IDENTIFIER [ CONSTANT ]
    (21) array_val -> . IDENTIFIER [ IDENTIFIER ]

    -               shift and go to state 28
    (               shift and go to state 29
    IDENTIFIER      shift and go to state 30
    CONSTANT        shift and go to state 31

    exp                            shift and go to state 67
    val                            shift and go to state 27
    array_val                      shift and go to state 32

state 46

    (33) exp -> exp * . exp
    (22) exp -> . val
    (30) exp -> . exp + exp
    (31) exp -> . exp - exp
    (32) exp -> . exp / exp
    (33) exp -> . exp * exp
    (34) exp -> . exp % exp
    (35) exp -> . val + val
    (36) exp -> . val - val
    (37) exp -> . val / val
    (38) exp -> . val * val
    (39) exp -> . val % val
    (40) exp -> . - exp
    (41) exp -> . ( exp )
    (17) val -> . IDENTIFIER
    (18) val -> . CONSTANT
    (19) val -> . array_val
    (20) array_val -> . IDENTIFIER [ CONSTANT ]
    (21) array_val -> . IDENTIFIER [ IDENTIFIER ]

    -               shift and go to state 28
    (               shift and go to state 29
    IDENTIFIER      shift and go to state 30
    CONSTANT        shift and go to state 31

    exp                            shift and go to state 68
    val                            shift and go to state 27
    array_val                      shift and go to state 32

state 47

    (34) exp -> exp % . exp
    (22) exp -> . val
    (30) exp -> . exp + exp
    (31) exp -> . exp - exp
    (32) exp -> . exp / exp
    (33) exp -> . exp * exp
    (34) exp -> . exp % exp
    (35) exp -> . val + val
    (36) exp -> . val - val
    (37) exp -> . val / val
    (38) exp -> . val * val
    (39) exp -> . val % val
    (40) exp -> . - exp
    (41) exp -> . ( exp )
    (17) val -> . IDENTIFIER
    (18) val -> . CONSTANT
    (19) val -> . array_val
    (20) array_val -> . IDENTIFIER [ CONSTANT ]
    (21) array_val -> . IDENTIFIER [ IDENTIFIER ]

    -               shift and go to state 28
    (               shift and go to state 29
    IDENTIFIER      shift and go to state 30
    CONSTANT        shift and go to state 31

    exp                            shift and go to state 69
    val                            shift and go to state 27
    array_val                      shift and go to state 32

state 48

    (35) exp -> val + . val
    (17) val -> . IDENTIFIER
    (18) val -> . CONSTANT
    (19) val -> . array_val
    (20) array_val -> . IDENTIFIER [ CONSTANT ]
    (21) array_val -> . IDENTIFIER [ IDENTIFIER ]

    IDENTIFIER      shift and go to state 30
    CONSTANT        shift and go to state 31

    val                            shift and go to state 70
    array_val                      shift and go to state 32

state 49

    (36) exp -> val - . val
    (17) val -> . IDENTIFIER
    (18) val -> . CONSTANT
    (19) val -> . array_val
    (20) array_val -> . IDENTIFIER [ CONSTANT ]
    (21) array_val -> . IDENTIFIER [ IDENTIFIER ]

    IDENTIFIER      shift and go to state 30
    CONSTANT        shift and go to state 31

    val                            shift and go to state 71
    array_val                      shift and go to state 32

state 50

    (37) exp -> val / . val
    (17) val -> . IDENTIFIER
    (18) val -> . CONSTANT
    (19) val -> . array_val
    (20) array_val -> . IDENTIFIER [ CONSTANT ]
    (21) array_val -> . IDENTIFIER [ IDENTIFIER ]

    IDENTIFIER      shift and go to state 30
    CONSTANT        shift and go to state 31

    val                            shift and go to state 72
    array_val                      shift and go to state 32

state 51

    (38) exp -> val * . val
    (17) val -> . IDENTIFIER
    (18) val -> . CONSTANT
    (19) val -> . array_val
    (20) array_val -> . IDENTIFIER [ CONSTANT ]
    (21) array_val -> . IDENTIFIER [ IDENTIFIER ]

    IDENTIFIER      shift and go to state 30
    CONSTANT        shift and go to state 31

    val                            shift and go to state 73
    array_val                      shift and go to state 32

state 52

    (39) exp -> val % . val
    (17) val -> . IDENTIFIER
    (18) val -> . CONSTANT
    (19) val -> . array_val
    (20) array_val -> . IDENTIFIER [ CONSTANT ]
    (21) array_val -> . IDENTIFIER [ IDENTIFIER ]

    IDENTIFIER      shift and go to state 30
    CONSTANT        shift and go to state 31

    val                            shift and go to state 74
    array_val                      shift and go to state 32

state 53

    (40) exp -> - exp .
    (30) exp -> exp . + exp
    (31) exp -> exp . - exp
    (32) exp -> exp . / exp
    (33) exp -> exp . * exp
    (34) exp -> exp . % exp

    <               reduce using rule 40 (exp -> - exp .)
    >               reduce using rule 40 (exp -> - exp .)
    =               reduce using rule 40 (exp -> - exp .)
    NOTEQ           reduce using rule 40 (exp -> - exp .)
    +               reduce using rule 40 (exp -> - exp .)
    -               reduce using rule 40 (exp -> - exp .)
    .               reduce using rule 40 (exp -> - exp .)
    )               reduce using rule 40 (exp -> - exp .)
    {               reduce using rule 40 (exp -> - exp .)
    /               shift and go to state 45
    *               shift and go to state 46
    %               shift and go to state 47

  ! /               [ reduce using rule 40 (exp -> - exp .) ]
  ! *               [ reduce using rule 40 (exp -> - exp .) ]
  ! %               [ reduce using rule 40 (exp -> - exp .) ]
  ! +               [ shift and go to state 43 ]
  ! -               [ shift and go to state 44 ]


state 54

    (41) exp -> ( exp . )
    (30) exp -> exp . + exp
    (31) exp -> exp . - exp
    (32) exp -> exp . / exp
    (33) exp -> exp . * exp
    (34) exp -> exp . % exp

    )               shift and go to state 75
    +               shift and go to state 43
    -               shift and go to state 44
    /               shift and go to state 45
    *               shift and go to state 46
    %               shift and go to state 47


state 55

    (20) array_val -> IDENTIFIER [ . CONSTANT ]
    (21) array_val -> IDENTIFIER [ . IDENTIFIER ]

    CONSTANT        shift and go to state 77
    IDENTIFIER      shift and go to state 76


state 56

    (13) loopExp -> LOOP assignL stmt . FINISH
    (1) stmt -> stmt . stmt
    (1) stmt -> . stmt stmt
    (2) stmt -> . assignExp .
    (3) stmt -> . arrayExp .
    (4) stmt -> . showExp .
    (5) stmt -> . cmpExp .
    (6) stmt -> . loopExp .
    (7) assignExp -> . IDENTIFIER ASSIGN exp
    (8) assignExp -> . t_CONSTANT IDENTIFIER ASSIGN exp
    (9) arrayExp -> . ARRAY IDENTIFIER ASSIGN [ member ]
    (23) showExp -> . SHOW CONSTANT
    (24) showExp -> . SHOW IDENTIFIER
    (25) showExp -> . SHOW STRING
    (16) cmpExp -> . CMP cond { stmt }
    (13) loopExp -> . LOOP assignL stmt FINISH

    FINISH          shift and go to state 78
    IDENTIFIER      shift and go to state 7
    t_CONSTANT      shift and go to state 8
    ARRAY           shift and go to state 9
    SHOW            shift and go to state 10
    CMP             shift and go to state 11
    LOOP            shift and go to state 12

    stmt                           shift and go to state 13
    assignExp                      shift and go to state 2
    arrayExp                       shift and go to state 3
    showExp                        shift and go to state 4
    cmpExp                         shift and go to state 5
    loopExp                        shift and go to state 6

state 57

    (14) assignL -> IDENTIFIER ASSIGN . expL
    (15) expL -> . ( CONSTANT , CONSTANT , CONSTANT )

    (               shift and go to state 80

    expL                           shift and go to state 79

state 58

    (8) assignExp -> t_CONSTANT IDENTIFIER ASSIGN exp .
    (30) exp -> exp . + exp
    (31) exp -> exp . - exp
    (32) exp -> exp . / exp
    (33) exp -> exp . * exp
    (34) exp -> exp . % exp

    .               reduce using rule 8 (assignExp -> t_CONSTANT IDENTIFIER ASSIGN exp .)
    +               shift and go to state 43
    -               shift and go to state 44
    /               shift and go to state 45
    *               shift and go to state 46
    %               shift and go to state 47


state 59

    (9) arrayExp -> ARRAY IDENTIFIER ASSIGN [ . member ]
    (10) member -> . CONSTANT member2

    CONSTANT        shift and go to state 82

    member                         shift and go to state 81

state 60

    (16) cmpExp -> CMP cond { stmt . }
    (1) stmt -> stmt . stmt
    (1) stmt -> . stmt stmt
    (2) stmt -> . assignExp .
    (3) stmt -> . arrayExp .
    (4) stmt -> . showExp .
    (5) stmt -> . cmpExp .
    (6) stmt -> . loopExp .
    (7) assignExp -> . IDENTIFIER ASSIGN exp
    (8) assignExp -> . t_CONSTANT IDENTIFIER ASSIGN exp
    (9) arrayExp -> . ARRAY IDENTIFIER ASSIGN [ member ]
    (23) showExp -> . SHOW CONSTANT
    (24) showExp -> . SHOW IDENTIFIER
    (25) showExp -> . SHOW STRING
    (16) cmpExp -> . CMP cond { stmt }
    (13) loopExp -> . LOOP assignL stmt FINISH

    }               shift and go to state 83
    IDENTIFIER      shift and go to state 7
    t_CONSTANT      shift and go to state 8
    ARRAY           shift and go to state 9
    SHOW            shift and go to state 10
    CMP             shift and go to state 11
    LOOP            shift and go to state 12

    stmt                           shift and go to state 13
    assignExp                      shift and go to state 2
    arrayExp                       shift and go to state 3
    showExp                        shift and go to state 4
    cmpExp                         shift and go to state 5
    loopExp                        shift and go to state 6

state 61

    (26) cond -> exp < exp .
    (30) exp -> exp . + exp
    (31) exp -> exp . - exp
    (32) exp -> exp . / exp
    (33) exp -> exp . * exp
    (34) exp -> exp . % exp

    {               reduce using rule 26 (cond -> exp < exp .)
    +               shift and go to state 43
    -               shift and go to state 44
    /               shift and go to state 45
    *               shift and go to state 46
    %               shift and go to state 47


state 62

    (27) cond -> exp > exp .
    (30) exp -> exp . + exp
    (31) exp -> exp . - exp
    (32) exp -> exp . / exp
    (33) exp -> exp . * exp
    (34) exp -> exp . % exp

    {               reduce using rule 27 (cond -> exp > exp .)
    +               shift and go to state 43
    -               shift and go to state 44
    /               shift and go to state 45
    *               shift and go to state 46
    %               shift and go to state 47


state 63

    (28) cond -> exp = exp .
    (30) exp -> exp . + exp
    (31) exp -> exp . - exp
    (32) exp -> exp . / exp
    (33) exp -> exp . * exp
    (34) exp -> exp . % exp

    {               reduce using rule 28 (cond -> exp = exp .)
    +               shift and go to state 43
    -               shift and go to state 44
    /               shift and go to state 45
    *               shift and go to state 46
    %               shift and go to state 47


state 64

    (29) cond -> exp NOTEQ exp .
    (30) exp -> exp . + exp
    (31) exp -> exp . - exp
    (32) exp -> exp . / exp
    (33) exp -> exp . * exp
    (34) exp -> exp . % exp

    {               reduce using rule 29 (cond -> exp NOTEQ exp .)
    +               shift and go to state 43
    -               shift and go to state 44
    /               shift and go to state 45
    *               shift and go to state 46
    %               shift and go to state 47


state 65

    (30) exp -> exp + exp .
    (30) exp -> exp . + exp
    (31) exp -> exp . - exp
    (32) exp -> exp . / exp
    (33) exp -> exp . * exp
    (34) exp -> exp . % exp

    <               reduce using rule 30 (exp -> exp + exp .)
    >               reduce using rule 30 (exp -> exp + exp .)
    =               reduce using rule 30 (exp -> exp + exp .)
    NOTEQ           reduce using rule 30 (exp -> exp + exp .)
    +               reduce using rule 30 (exp -> exp + exp .)
    -               reduce using rule 30 (exp -> exp + exp .)
    .               reduce using rule 30 (exp -> exp + exp .)
    )               reduce using rule 30 (exp -> exp + exp .)
    {               reduce using rule 30 (exp -> exp + exp .)
    /               shift and go to state 45
    *               shift and go to state 46
    %               shift and go to state 47

  ! /               [ reduce using rule 30 (exp -> exp + exp .) ]
  ! *               [ reduce using rule 30 (exp -> exp + exp .) ]
  ! %               [ reduce using rule 30 (exp -> exp + exp .) ]
  ! +               [ shift and go to state 43 ]
  ! -               [ shift and go to state 44 ]


state 66

    (31) exp -> exp - exp .
    (30) exp -> exp . + exp
    (31) exp -> exp . - exp
    (32) exp -> exp . / exp
    (33) exp -> exp . * exp
    (34) exp -> exp . % exp

    <               reduce using rule 31 (exp -> exp - exp .)
    >               reduce using rule 31 (exp -> exp - exp .)
    =               reduce using rule 31 (exp -> exp - exp .)
    NOTEQ           reduce using rule 31 (exp -> exp - exp .)
    +               reduce using rule 31 (exp -> exp - exp .)
    -               reduce using rule 31 (exp -> exp - exp .)
    .               reduce using rule 31 (exp -> exp - exp .)
    )               reduce using rule 31 (exp -> exp - exp .)
    {               reduce using rule 31 (exp -> exp - exp .)
    /               shift and go to state 45
    *               shift and go to state 46
    %               shift and go to state 47

  ! /               [ reduce using rule 31 (exp -> exp - exp .) ]
  ! *               [ reduce using rule 31 (exp -> exp - exp .) ]
  ! %               [ reduce using rule 31 (exp -> exp - exp .) ]
  ! +               [ shift and go to state 43 ]
  ! -               [ shift and go to state 44 ]


state 67

    (32) exp -> exp / exp .
    (30) exp -> exp . + exp
    (31) exp -> exp . - exp
    (32) exp -> exp . / exp
    (33) exp -> exp . * exp
    (34) exp -> exp . % exp

    <               reduce using rule 32 (exp -> exp / exp .)
    >               reduce using rule 32 (exp -> exp / exp .)
    =               reduce using rule 32 (exp -> exp / exp .)
    NOTEQ           reduce using rule 32 (exp -> exp / exp .)
    +               reduce using rule 32 (exp -> exp / exp .)
    -               reduce using rule 32 (exp -> exp / exp .)
    /               reduce using rule 32 (exp -> exp / exp .)
    *               reduce using rule 32 (exp -> exp / exp .)
    %               reduce using rule 32 (exp -> exp / exp .)
    .               reduce using rule 32 (exp -> exp / exp .)
    )               reduce using rule 32 (exp -> exp / exp .)
    {               reduce using rule 32 (exp -> exp / exp .)

  ! +               [ shift and go to state 43 ]
  ! -               [ shift and go to state 44 ]
  ! /               [ shift and go to state 45 ]
  ! *               [ shift and go to state 46 ]
  ! %               [ shift and go to state 47 ]


state 68

    (33) exp -> exp * exp .
    (30) exp -> exp . + exp
    (31) exp -> exp . - exp
    (32) exp -> exp . / exp
    (33) exp -> exp . * exp
    (34) exp -> exp . % exp

    <               reduce using rule 33 (exp -> exp * exp .)
    >               reduce using rule 33 (exp -> exp * exp .)
    =               reduce using rule 33 (exp -> exp * exp .)
    NOTEQ           reduce using rule 33 (exp -> exp * exp .)
    +               reduce using rule 33 (exp -> exp * exp .)
    -               reduce using rule 33 (exp -> exp * exp .)
    /               reduce using rule 33 (exp -> exp * exp .)
    *               reduce using rule 33 (exp -> exp * exp .)
    %               reduce using rule 33 (exp -> exp * exp .)
    .               reduce using rule 33 (exp -> exp * exp .)
    )               reduce using rule 33 (exp -> exp * exp .)
    {               reduce using rule 33 (exp -> exp * exp .)

  ! +               [ shift and go to state 43 ]
  ! -               [ shift and go to state 44 ]
  ! /               [ shift and go to state 45 ]
  ! *               [ shift and go to state 46 ]
  ! %               [ shift and go to state 47 ]


state 69

    (34) exp -> exp % exp .
    (30) exp -> exp . + exp
    (31) exp -> exp . - exp
    (32) exp -> exp . / exp
    (33) exp -> exp . * exp
    (34) exp -> exp . % exp

    <               reduce using rule 34 (exp -> exp % exp .)
    >               reduce using rule 34 (exp -> exp % exp .)
    =               reduce using rule 34 (exp -> exp % exp .)
    NOTEQ           reduce using rule 34 (exp -> exp % exp .)
    +               reduce using rule 34 (exp -> exp % exp .)
    -               reduce using rule 34 (exp -> exp % exp .)
    /               reduce using rule 34 (exp -> exp % exp .)
    *               reduce using rule 34 (exp -> exp % exp .)
    %               reduce using rule 34 (exp -> exp % exp .)
    .               reduce using rule 34 (exp -> exp % exp .)
    )               reduce using rule 34 (exp -> exp % exp .)
    {               reduce using rule 34 (exp -> exp % exp .)

  ! +               [ shift and go to state 43 ]
  ! -               [ shift and go to state 44 ]
  ! /               [ shift and go to state 45 ]
  ! *               [ shift and go to state 46 ]
  ! %               [ shift and go to state 47 ]


state 70

    (35) exp -> val + val .

    <               reduce using rule 35 (exp -> val + val .)
    >               reduce using rule 35 (exp -> val + val .)
    =               reduce using rule 35 (exp -> val + val .)
    NOTEQ           reduce using rule 35 (exp -> val + val .)
    +               reduce using rule 35 (exp -> val + val .)
    -               reduce using rule 35 (exp -> val + val .)
    /               reduce using rule 35 (exp -> val + val .)
    *               reduce using rule 35 (exp -> val + val .)
    %               reduce using rule 35 (exp -> val + val .)
    .               reduce using rule 35 (exp -> val + val .)
    )               reduce using rule 35 (exp -> val + val .)
    {               reduce using rule 35 (exp -> val + val .)


state 71

    (36) exp -> val - val .

    <               reduce using rule 36 (exp -> val - val .)
    >               reduce using rule 36 (exp -> val - val .)
    =               reduce using rule 36 (exp -> val - val .)
    NOTEQ           reduce using rule 36 (exp -> val - val .)
    +               reduce using rule 36 (exp -> val - val .)
    -               reduce using rule 36 (exp -> val - val .)
    /               reduce using rule 36 (exp -> val - val .)
    *               reduce using rule 36 (exp -> val - val .)
    %               reduce using rule 36 (exp -> val - val .)
    .               reduce using rule 36 (exp -> val - val .)
    )               reduce using rule 36 (exp -> val - val .)
    {               reduce using rule 36 (exp -> val - val .)


state 72

    (37) exp -> val / val .

    <               reduce using rule 37 (exp -> val / val .)
    >               reduce using rule 37 (exp -> val / val .)
    =               reduce using rule 37 (exp -> val / val .)
    NOTEQ           reduce using rule 37 (exp -> val / val .)
    +               reduce using rule 37 (exp -> val / val .)
    -               reduce using rule 37 (exp -> val / val .)
    /               reduce using rule 37 (exp -> val / val .)
    *               reduce using rule 37 (exp -> val / val .)
    %               reduce using rule 37 (exp -> val / val .)
    .               reduce using rule 37 (exp -> val / val .)
    )               reduce using rule 37 (exp -> val / val .)
    {               reduce using rule 37 (exp -> val / val .)


state 73

    (38) exp -> val * val .

    <               reduce using rule 38 (exp -> val * val .)
    >               reduce using rule 38 (exp -> val * val .)
    =               reduce using rule 38 (exp -> val * val .)
    NOTEQ           reduce using rule 38 (exp -> val * val .)
    +               reduce using rule 38 (exp -> val * val .)
    -               reduce using rule 38 (exp -> val * val .)
    /               reduce using rule 38 (exp -> val * val .)
    *               reduce using rule 38 (exp -> val * val .)
    %               reduce using rule 38 (exp -> val * val .)
    .               reduce using rule 38 (exp -> val * val .)
    )               reduce using rule 38 (exp -> val * val .)
    {               reduce using rule 38 (exp -> val * val .)


state 74

    (39) exp -> val % val .

    <               reduce using rule 39 (exp -> val % val .)
    >               reduce using rule 39 (exp -> val % val .)
    =               reduce using rule 39 (exp -> val % val .)
    NOTEQ           reduce using rule 39 (exp -> val % val .)
    +               reduce using rule 39 (exp -> val % val .)
    -               reduce using rule 39 (exp -> val % val .)
    /               reduce using rule 39 (exp -> val % val .)
    *               reduce using rule 39 (exp -> val % val .)
    %               reduce using rule 39 (exp -> val % val .)
    .               reduce using rule 39 (exp -> val % val .)
    )               reduce using rule 39 (exp -> val % val .)
    {               reduce using rule 39 (exp -> val % val .)


state 75

    (41) exp -> ( exp ) .

    <               reduce using rule 41 (exp -> ( exp ) .)
    >               reduce using rule 41 (exp -> ( exp ) .)
    =               reduce using rule 41 (exp -> ( exp ) .)
    NOTEQ           reduce using rule 41 (exp -> ( exp ) .)
    +               reduce using rule 41 (exp -> ( exp ) .)
    -               reduce using rule 41 (exp -> ( exp ) .)
    /               reduce using rule 41 (exp -> ( exp ) .)
    *               reduce using rule 41 (exp -> ( exp ) .)
    %               reduce using rule 41 (exp -> ( exp ) .)
    .               reduce using rule 41 (exp -> ( exp ) .)
    )               reduce using rule 41 (exp -> ( exp ) .)
    {               reduce using rule 41 (exp -> ( exp ) .)


state 76

    (21) array_val -> IDENTIFIER [ IDENTIFIER . ]

    ]               shift and go to state 84


state 77

    (20) array_val -> IDENTIFIER [ CONSTANT . ]

    ]               shift and go to state 85


state 78

    (13) loopExp -> LOOP assignL stmt FINISH .

    .               reduce using rule 13 (loopExp -> LOOP assignL stmt FINISH .)


state 79

    (14) assignL -> IDENTIFIER ASSIGN expL .

    IDENTIFIER      reduce using rule 14 (assignL -> IDENTIFIER ASSIGN expL .)
    t_CONSTANT      reduce using rule 14 (assignL -> IDENTIFIER ASSIGN expL .)
    ARRAY           reduce using rule 14 (assignL -> IDENTIFIER ASSIGN expL .)
    SHOW            reduce using rule 14 (assignL -> IDENTIFIER ASSIGN expL .)
    CMP             reduce using rule 14 (assignL -> IDENTIFIER ASSIGN expL .)
    LOOP            reduce using rule 14 (assignL -> IDENTIFIER ASSIGN expL .)


state 80

    (15) expL -> ( . CONSTANT , CONSTANT , CONSTANT )

    CONSTANT        shift and go to state 86


state 81

    (9) arrayExp -> ARRAY IDENTIFIER ASSIGN [ member . ]

    ]               shift and go to state 87


state 82

    (10) member -> CONSTANT . member2
    (11) member2 -> . , CONSTANT member2
    (12) member2 -> . empty empty empty
    (42) empty -> .

    ,               shift and go to state 89
    ]               reduce using rule 42 (empty -> .)

    member2                        shift and go to state 88
    empty                          shift and go to state 90

state 83

    (16) cmpExp -> CMP cond { stmt } .

    .               reduce using rule 16 (cmpExp -> CMP cond { stmt } .)


state 84

    (21) array_val -> IDENTIFIER [ IDENTIFIER ] .

    +               reduce using rule 21 (array_val -> IDENTIFIER [ IDENTIFIER ] .)
    -               reduce using rule 21 (array_val -> IDENTIFIER [ IDENTIFIER ] .)
    /               reduce using rule 21 (array_val -> IDENTIFIER [ IDENTIFIER ] .)
    *               reduce using rule 21 (array_val -> IDENTIFIER [ IDENTIFIER ] .)
    %               reduce using rule 21 (array_val -> IDENTIFIER [ IDENTIFIER ] .)
    <               reduce using rule 21 (array_val -> IDENTIFIER [ IDENTIFIER ] .)
    >               reduce using rule 21 (array_val -> IDENTIFIER [ IDENTIFIER ] .)
    =               reduce using rule 21 (array_val -> IDENTIFIER [ IDENTIFIER ] .)
    NOTEQ           reduce using rule 21 (array_val -> IDENTIFIER [ IDENTIFIER ] .)
    .               reduce using rule 21 (array_val -> IDENTIFIER [ IDENTIFIER ] .)
    )               reduce using rule 21 (array_val -> IDENTIFIER [ IDENTIFIER ] .)
    {               reduce using rule 21 (array_val -> IDENTIFIER [ IDENTIFIER ] .)


state 85

    (20) array_val -> IDENTIFIER [ CONSTANT ] .

    +               reduce using rule 20 (array_val -> IDENTIFIER [ CONSTANT ] .)
    -               reduce using rule 20 (array_val -> IDENTIFIER [ CONSTANT ] .)
    /               reduce using rule 20 (array_val -> IDENTIFIER [ CONSTANT ] .)
    *               reduce using rule 20 (array_val -> IDENTIFIER [ CONSTANT ] .)
    %               reduce using rule 20 (array_val -> IDENTIFIER [ CONSTANT ] .)
    <               reduce using rule 20 (array_val -> IDENTIFIER [ CONSTANT ] .)
    >               reduce using rule 20 (array_val -> IDENTIFIER [ CONSTANT ] .)
    =               reduce using rule 20 (array_val -> IDENTIFIER [ CONSTANT ] .)
    NOTEQ           reduce using rule 20 (array_val -> IDENTIFIER [ CONSTANT ] .)
    .               reduce using rule 20 (array_val -> IDENTIFIER [ CONSTANT ] .)
    )               reduce using rule 20 (array_val -> IDENTIFIER [ CONSTANT ] .)
    {               reduce using rule 20 (array_val -> IDENTIFIER [ CONSTANT ] .)


state 86

    (15) expL -> ( CONSTANT . , CONSTANT , CONSTANT )

    ,               shift and go to state 91


state 87

    (9) arrayExp -> ARRAY IDENTIFIER ASSIGN [ member ] .

    .               reduce using rule 9 (arrayExp -> ARRAY IDENTIFIER ASSIGN [ member ] .)


state 88

    (10) member -> CONSTANT member2 .

    ]               reduce using rule 10 (member -> CONSTANT member2 .)


state 89

    (11) member2 -> , . CONSTANT member2

    CONSTANT        shift and go to state 92


state 90

    (12) member2 -> empty . empty empty
    (42) empty -> .

    ]               reduce using rule 42 (empty -> .)

    empty                          shift and go to state 93

state 91

    (15) expL -> ( CONSTANT , . CONSTANT , CONSTANT )

    CONSTANT        shift and go to state 94


state 92

    (11) member2 -> , CONSTANT . member2
    (11) member2 -> . , CONSTANT member2
    (12) member2 -> . empty empty empty
    (42) empty -> .

    ,               shift and go to state 89
    ]               reduce using rule 42 (empty -> .)

    member2                        shift and go to state 95
    empty                          shift and go to state 90

state 93

    (12) member2 -> empty empty . empty
    (42) empty -> .

    ]               reduce using rule 42 (empty -> .)

    empty                          shift and go to state 96

state 94

    (15) expL -> ( CONSTANT , CONSTANT . , CONSTANT )

    ,               shift and go to state 97


state 95

    (11) member2 -> , CONSTANT member2 .

    ]               reduce using rule 11 (member2 -> , CONSTANT member2 .)


state 96

    (12) member2 -> empty empty empty .

    ]               reduce using rule 12 (member2 -> empty empty empty .)


state 97

    (15) expL -> ( CONSTANT , CONSTANT , . CONSTANT )

    CONSTANT        shift and go to state 98


state 98

    (15) expL -> ( CONSTANT , CONSTANT , CONSTANT . )

    )               shift and go to state 99


state 99

    (15) expL -> ( CONSTANT , CONSTANT , CONSTANT ) .

    IDENTIFIER      reduce using rule 15 (expL -> ( CONSTANT , CONSTANT , CONSTANT ) .)
    t_CONSTANT      reduce using rule 15 (expL -> ( CONSTANT , CONSTANT , CONSTANT ) .)
    ARRAY           reduce using rule 15 (expL -> ( CONSTANT , CONSTANT , CONSTANT ) .)
    SHOW            reduce using rule 15 (expL -> ( CONSTANT , CONSTANT , CONSTANT ) .)
    CMP             reduce using rule 15 (expL -> ( CONSTANT , CONSTANT , CONSTANT ) .)
    LOOP            reduce using rule 15 (expL -> ( CONSTANT , CONSTANT , CONSTANT ) .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IDENTIFIER in state 13 resolved as shift
WARNING: shift/reduce conflict for t_CONSTANT in state 13 resolved as shift
WARNING: shift/reduce conflict for ARRAY in state 13 resolved as shift
WARNING: shift/reduce conflict for SHOW in state 13 resolved as shift
WARNING: shift/reduce conflict for CMP in state 13 resolved as shift
WARNING: shift/reduce conflict for LOOP in state 13 resolved as shift
WARNING: shift/reduce conflict for + in state 27 resolved as shift
WARNING: shift/reduce conflict for - in state 27 resolved as shift
WARNING: shift/reduce conflict for / in state 27 resolved as shift
WARNING: shift/reduce conflict for * in state 27 resolved as shift
WARNING: shift/reduce conflict for % in state 27 resolved as shift
